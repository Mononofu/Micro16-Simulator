R6 <- R0 // initial setup
R7 <- R0
R10 <- 74 // just a test value
R3 <- R0

	// our mask for MSB
R5 <- lsh(R1 + R1) // 4
R5 <- lsh(R5 + R5) // 16
R5 <- lsh(R5 + R5) // 64
R5 <- lsh(R5 + R5) // 256
R5 <- lsh(R5 + R5) // 1024
R5 <- lsh(R5 + R5) // 4096
R5 <- lsh(R5 + R5) // 16k
R5 <- lsh(R5) 		// 32k - left most bit is 1
R11 <- -R5			// mask to zero MSB
R12 <- (R2 + R2)		// mask to zero LSB

goto S

A: // state Z0
R3 <- (R3 + R1)
(R4); if Z goto S // only change state if input is 1
R6 <- R1
goto S

B: // state Z1
R6 <- R0
R7 <- R1
goto S
C:
(R4); if Z goto B // only change s if I is 0
goto S

E: // state Z2
(R4); if Z goto S
R6 <- R1
goto S

G: // state Z3
R3 <- (R3 + R1)
goto H
I:
R6 <- R0
R7 <- R0
goto S
H:
(R4); if Z goto I
goto S

S: // begin of main loop
(R5); if Z goto END 	// quit
R4 <- (R10 & R5) 	// check current bit of R10, beginning from the left
(R4); if Z goto Y 	// everythin is already 0
R4 <- R1 			// otherwise, we want to make sure only the LSB is set
Y:
R5 <- rsh(R5)	 // right shift R5 so the next bit we check is to the right
R5 <- (R5 & R11) // and make sure the MSB is 0
R3 <- lsh(R3)	 // left shift R3 to make room for the next output
R3 <- (R3 & R12) // and also ensure that LSB is 0

(R6); if Z goto M  // switch execution according to state
(R7); if Z goto N
goto G
N:
goto C
M:
(R7); if Z goto O
goto E
O:
goto A

END: // the end